<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .leaflet-container { touch-action: pan-y pinch-zoom; -webkit-tap-highlight-color: transparent; }

    .polygon-label {
      font-weight: bold;
      color: #1b5e20;
      text-shadow: 1px 1px 2px white;
      font-size: 14px;
    }

    .leaflet-control-attribution a {
      pointer-events: none !important;
      cursor: default !important;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    /* ============================
       TILE + MAP INIT
    ============================= */
    const tileUrl =
      "https://api.maptiler.com/maps/streets-v2/256/{z}/{x}/{y}.png?key=vt8j60co865zsOqac3J6";

    const DEFAULT_CENTER = [12.6820, 78.6201];
    const DEFAULT_ZOOM = 15;

    const map = L.map("map", {
      zoomControl: true,
      minZoom: 13,
      maxZoom: 18,
    }).setView(DEFAULT_CENTER, DEFAULT_ZOOM);

    L.tileLayer(tileUrl, {
      maxZoom: 19,
      tileSize: 512,
      zoomOffset: -1,
    }).addTo(map);

    map.attributionControl.setPrefix("");

    /* ============================
       ICONS
    ============================= */
    const userIcon = L.icon({
      iconUrl: "https://cdn-icons-png.flaticon.com/512/535/535239.png",
      iconSize: [36, 36],
    });

    const pickupIcon = L.icon({
      iconUrl: "https://cdn-icons-png.flaticon.com/512/684/684908.png",
      iconSize: [40, 40],
    });

    /* ============================
       STATE
    ============================= */
    let userMarker = null;
    let pickupMarker = null;
    let dropMarker = null;
    let pendingMarker = null;
    let routeLine = null;

    let subareaPolygons = [];
    let allowedBounds = null;

    let firstLocationSet = false;
    let pendingUserLocation = null;
    let polygonsLoaded = false;
    let pendingCenterOnUser = false;

    /* ============================
       POINT-IN-POLYGON (helper)
    ============================= */
    function pointInPolygon(point, vs) {
      const x = point[1], y = point[0];
      let inside = false;
      for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i][1], yi = vs[i][0];
        const xj = vs[j][1], yj = vs[j][0];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.0000001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function polygonContainsLatLng(poly, latlng) {
      const ring = poly.getLatLngs()[0];
      const vs = ring.map(p => [p.lat, p.lng]);
      return pointInPolygon([latlng.lat, latlng.lng], vs);
    }

    function isInsideAnyPolygon(latlng) {
      return subareaPolygons.some(poly => polygonContainsLatLng(poly, latlng));
    }

    /* ============================
       USER LOCATION HANDLING
       (always center on first user location)
    ============================= */
    function setUserLocation(lat, lng, centerMap = true, zoom = 17) {
      // always show marker immediately
      if (!userMarker) {
        userMarker = L.marker([lat, lng], { icon: userIcon }).addTo(map);
      } else {
        userMarker.setLatLng([lat, lng]);
      }

      // ALWAYS center on first user location if requested
      if (centerMap) {
        map.setView([lat, lng], zoom);
        firstLocationSet = true;
        pendingCenterOnUser = false;
      } else if (!centerMap && !firstLocationSet) {
        pendingUserLocation = { lat, lng, zoom };
        pendingCenterOnUser = true;
      }
    }

    /* ============================
       ROUTE DRAW
    ============================= */
    function drawRoute(coords) {
      if (routeLine) map.removeLayer(routeLine);
      if (!coords || coords.length < 2) return;

      const latlngs = coords.map(p => [p.latitude, p.longitude]);
      routeLine = L.polyline(latlngs, { color: "blue", weight: 5 }).addTo(map);
    }

    /* ============================
       LOAD SUBAREAS
    ============================= */
    function loadSubareas(json) {
      subareaPolygons.forEach(p => map.removeLayer(p));
      subareaPolygons = [];
      allowedBounds = null;

      Object.keys(json || {}).forEach(name => {
        const pts = json[name].map(p => [p.lat, p.lng]);
        if (pts.length < 3) return;

        const poly = L.polygon(pts, {
          color: "#2e7d32",
          fillColor: "#81c784",
          fillOpacity: 0.25
        }).addTo(map);

        subareaPolygons.push(poly);

        if (!allowedBounds) allowedBounds = poly.getBounds();
        else allowedBounds.extend(poly.getBounds());

        const center = poly.getBounds().getCenter();
        L.marker(center, { icon: L.divIcon({
          html: `<div class="polygon-label">${name}</div>`,
          className: ""
        })}).addTo(map);
      });

      polygonsLoaded = true;

      if (allowedBounds) {
        map.setMaxBounds(allowedBounds.pad(0.02));
      }

      // If user location came earlier & told to center — now apply
      if (!firstLocationSet && pendingCenterOnUser && pendingUserLocation) {
        map.setView(
          [pendingUserLocation.lat, pendingUserLocation.lng],
          pendingUserLocation.zoom || 17
        );
        firstLocationSet = true;
        pendingUserLocation = null;
        pendingCenterOnUser = false;
        return;
      }

      // If no user location yet → fit polygon bounds
      if (!firstLocationSet && allowedBounds) {
        map.fitBounds(allowedBounds.pad(0.02));
      }
    }

    /* ============================
       UPDATE MARKERS (pickup/drop/pending/route)
    ============================= */
    function updateMarkers(payload) {
      const { pickup, drop, pendingDrop, routeCoords } = payload;

      if (pickup && (pickup.latitude || pickup.lat)) {
        const lat = pickup.latitude || pickup.lat;
        const lng = pickup.longitude || pickup.lng;
        if (!pickupMarker) pickupMarker = L.marker([lat, lng], { icon: pickupIcon }).addTo(map);
        else pickupMarker.setLatLng([lat, lng]);
      } else if (pickupMarker) {
        map.removeLayer(pickupMarker);
        pickupMarker = null;
      }

      if (drop && (drop.latitude || drop.lat)) {
        const lat = drop.latitude || drop.lat;
        const lng = drop.longitude || drop.lng;
        if (!dropMarker) dropMarker = L.marker([lat, lng]).addTo(map);
        else dropMarker.setLatLng([lat, lng]);
      } else if (dropMarker) {
        map.removeLayer(dropMarker);
        dropMarker = null;
      }

      if (pendingDrop && (pendingDrop.latitude || pendingDrop.lat)) {
        const lat = pendingDrop.latitude || pendingDrop.lat;
        const lng = pendingDrop.longitude || pendingDrop.lng;
        if (!pendingMarker) pendingMarker = L.marker([lat, lng], { opacity: 0.9 }).addTo(map);
        else pendingMarker.setLatLng([lat, lng]);
      } else if (pendingMarker) {
        map.removeLayer(pendingMarker);
        pendingMarker = null;
      }

      if (routeCoords) drawRoute(routeCoords);
    }

    /* ============================
       SNAP / NEAREST POLYGON (helpers)
    ============================= */
    function haversine(a, b) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const A = Math.sin(dLat/2)**2 +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
    }

    function nearestPolygonCenter(latlng) {
      let best = null;
      let bestDist = Infinity;
      subareaPolygons.forEach(poly => {
        const c = poly.getBounds().getCenter();
        const d = haversine(latlng, {lat: c.lat, lng: c.lng});
        if (d < bestDist) { bestDist = d; best = c; }
      });
      return best;
    }

    /* ============================
       CONFIRM DROP (uses map center)
       Posts back: { type: "confirmDrop", lat, lng, snapped }
    ============================= */
    function confirmDrop() {
      const c = map.getCenter();

      if (isInsideAnyPolygon(c)) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: "confirmDrop",
          lat: c.lat,
          lng: c.lng,
          snapped: false
        }));
        return;
      }

      // center outside → snap to nearest polygon center
      const snap = nearestPolygonCenter(c);
      if (!snap) {
        // no polygon available — return invalidArea to RN
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: "invalidArea" }));
        return;
      }

      map.flyTo([snap.lat, snap.lng], map.getZoom());

      setTimeout(() => {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: "confirmDrop",
          lat: snap.lat,
          lng: snap.lng,
          snapped: true
        }));
      }, 500);
    }

    /* RN calls this via postMessage({type:"confirm"}) */
    function handleConfirm() {
      confirmDrop();
    }

    /* ============================
       HANDLE MESSAGES FROM RN
    ============================= */
    function handleMessage(event) {
      let raw = event.data || event;

      try {
        const msg = JSON.parse(raw);

        if (msg.type === "loadSubareas") return loadSubareas(msg.data);
        if (msg.type === "confirm") return handleConfirm();
        if (msg.type === "update") {
          // cameraCenter from RN
          if (msg.cameraCenter) {
            let lat, lng;

            if (Array.isArray(msg.cameraCenter)) {
              const maybeLng = msg.cameraCenter[0];
              const maybeLat = msg.cameraCenter[1];
              lat = maybeLat; lng = maybeLng;
            } else {
              lat = msg.cameraCenter.lat;
              lng = msg.cameraCenter.lng;
            }

            if (!isNaN(lat) && !isNaN(lng)) {
              map.setView([lat, lng], msg.cameraZoom || map.getZoom());
            }
          }

          updateMarkers(msg);
          return;
        }

        if (msg.type === "userLocation") {
          const lat = msg.lat ?? msg.latitude;
          const lng = msg.lng ?? msg.longitude;
          if (typeof lat === "number" && typeof lng === "number") {
            setUserLocation(lat, lng, msg.center !== false, msg.zoom || 17);
          }
          return;
        }

        if (msg.type === "setCamera" && msg.center) {
          map.setView([msg.center.lat, msg.center.lng], msg.zoom || map.getZoom());
          return;
        }

      } catch (e) {
        console.warn("Message parse error", raw, e);
      }
    }

    document.addEventListener("message", handleMessage);
    window.addEventListener("message", handleMessage);

    if (window.ReactNativeWebView)
      window.ReactNativeWebView.onMessage = handleMessage;

    /* ============================
       READY SIGNAL
    ============================= */
    window.ReactNativeWebView?.postMessage(JSON.stringify({type: "mapReady"}));
  </script>
</body>
</html>
